import inspect
import re
from pathlib import Path
from typing import Callable, Dict, Optional

import dash_bootstrap_components as dbc
from dash import (ClientsideFunction, Dash, Input, Output, State, callback,
                  clientside_callback, dcc, html)
from utils import SingletonMeta


def relative_path(file_path):
    return str(Path(__file__).parent / file_path)


def read_template():
    path = relative_path("template.html")
    with open(path, "r", encoding="utf-8") as f:
        content = f.read()
    return content


app = Dash(
    __name__,
    index_string=read_template(),
    external_stylesheets=[dbc.themes.BOOTSTRAP],
    assets_ignore=".*pyodide.*",
)

label = html.Label(id="label", children="0")
add_button = dbc.Button(id="add", children="Add")
substract_button = dbc.Button(id="substract", children="Substract")
app.layout = html.Div(
    [
        html.H1("My pyodide app"),
        label,
        dbc.Row([dbc.Col(add_button), dbc.Col(substract_button)]),
    ]
)

# TODO make a singleton


class PythonClientSideCallbacks(Dict[str, str], metaclass=SingletonMeta):
    def __init__(self):
        self._script_path = relative_path("./assets/script.py")
        super().__init__({})
        with open(self._script_path, mode="w") as f:
            f.write("# Autogenerated file, do not write.\n\n")

    def register(self, func: Callable):
        function_name = func.__name__
        if function_name is self:
            raise KeyError(f"{function_name} is already registered.")
        function_code = inspect.getsource(func)
        # match = re.match(r'(?:@.*\(.*?\)\n)(def.*)', function_code, flags=re.DOTALL)
        match = re.match(r"(?:.*?)(def.*)", function_code, flags=re.DOTALL)
        self[function_name] = match.group(1)
        with open(self._script_path, mode="a") as f:
            f.write(self[function_name])
            f.write("\n")


def clientside_python_callback(*args, **kwargs):
    def wrapper(func):
        callbacks = PythonClientSideCallbacks()
        callbacks.register(func)
        js_code = f"""
        async function(...args) {{
            const result = await asyncRunFunction('{func.__name__}', args);
            return result.results
        }}"""
        clientside_callback(js_code, *args, **kwargs)

        return func
    return wrapper


@clientside_python_callback(
    Output(label, 'children', allow_duplicate=True),
    Input(add_button, 'n_clicks'),
    State(label, 'children'),
    prevent_initial_call='initial_duplicate',
)
def python_add(n_clicks, label):
    if not n_clicks:
        return 1
    return int(label) + 1


@clientside_python_callback(
    Output(label, 'children'),
    Input(substract_button, 'n_clicks'),
    State(label, 'children')
)
def python_substract(n_clicks, label):
    if not n_clicks:
        return 1
    return int(label) - 1


DEBUG = True

if __name__ == "__main__":
    app.run(debug=DEBUG)
